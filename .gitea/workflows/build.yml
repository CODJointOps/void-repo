name: build

on:
  push:
    branches:
      - master
    paths:
      - 'srcpkgs/**'
  workflow_dispatch:

jobs:
  build:
    name: Build packages
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/void-linux/void-${{ matrix.config.libc }}-full:20250616R1
      options: --privileged
      volumes:
        - /dev:/dev
      env:
        ARCH: '${{ matrix.config.arch }}'
        BOOTSTRAP: '${{ matrix.config.host }}'
        TEST: '${{ matrix.config.test }}'
    strategy:
      fail-fast: false
      matrix:
        config:
          - { arch: x86_64,       host: x86_64,      libc: glibc, test: 1 }
          - { arch: aarch64,      host: x86_64,      libc: glibc, test: 0 }
          - { arch: x86_64-musl,  host: x86_64-musl, libc: musl,  test: 1 }
          - { arch: aarch64-musl, host: x86_64-musl, libc: musl,  test: 0 }

    permissions:
      contents: write

    steps:
      - name: Prepare container
        run: |
          mkdir -p /etc/xbps.d && cp /usr/share/xbps.d/*-repository-*.conf /etc/xbps.d/
          sed -i 's|repo-default|repo-ci|g' /etc/xbps.d/*-repository-*.conf
          xbps-install -Syu xbps && xbps-install -yu && xbps-install -y sudo bash curl git git-lfs
          useradd -G xbuilder -M builder

      - name: Configure git credentials for LFS
        env:
          ACCESS_GIT: ${{ secrets.ACCESS_GIT }}
          ACCESS_GIT_USER: ${{ secrets.ACCESS_GIT_USER }}
          REPO_OWNER: ${{ gitea.repository_owner }}
          REPO_FULL: ${{ gitea.repository }}
        run: |
          GIT_USER="${ACCESS_GIT_USER:-$REPO_OWNER}"
          printf "%s\n" \
            "https://${GIT_USER}:${ACCESS_GIT}@git.deadzone.lol/${REPO_FULL}.git" \
            "https://${GIT_USER}:${ACCESS_GIT}@git.deadzone.lol" > ~/.git-credentials
          git config --global credential.helper store
          git config --global credential.useHttpPath false
          for key in $(git config --global --name-only --get-regexp '^http\\..*\\.extraheader$' 2>/dev/null || true); do
              git config --global --unset-all "$key" || true
          done
          git lfs install

      - name: Checkout this repo
        env:
          ACCESS_GIT: ${{ secrets.ACCESS_GIT }}
          ACCESS_GIT_USER: ${{ secrets.ACCESS_GIT_USER }}
          REPO_OWNER: ${{ gitea.repository_owner }}
        run: |
          GIT_USER="${ACCESS_GIT_USER:-$REPO_OWNER}"
          REMOTE_PUBLIC="https://git.deadzone.lol/${{ gitea.repository }}.git"
          REMOTE_AUTH="https://${GIT_USER}:${ACCESS_GIT}@git.deadzone.lol/${{ gitea.repository }}.git"

          cloned=0
          for attempt in 1 2 3; do
              rm -rf extra
              # Public repo: prefer unauthenticated clone, fall back to token auth.
              if git clone --depth 1 "$REMOTE_PUBLIC" extra; then
                  cloned=1
                  break
              fi
              rm -rf extra
              if git clone --depth 1 "$REMOTE_AUTH" extra; then
                  cloned=1
                  break
              fi
              if [ "$attempt" -lt 3 ]; then
                  delay=$((attempt * 10))
                  echo "Checkout failed (attempt ${attempt}/3), retrying in ${delay}s..."
                  sleep "$delay"
              fi
          done
          if [ "$cloned" -ne 1 ]; then
              echo "Checkout failed after 3 attempts."
              exit 1
          fi

          cd extra
          git remote set-url origin "$REMOTE_PUBLIC"
          if [ -n "${{ gitea.event.before }}" ] && [ "${{ gitea.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              git fetch --no-tags "$REMOTE_PUBLIC" "${{ gitea.event.before }}" --depth 1 \
                  || git fetch --no-tags "$REMOTE_AUTH" "${{ gitea.event.before }}" --depth 1 \
                  || true
          fi
          git fetch --no-tags "$REMOTE_PUBLIC" "${{ gitea.sha }}" --depth 1 \
              || git fetch --no-tags "$REMOTE_AUTH" "${{ gitea.sha }}" --depth 1
          git checkout --detach "${{ gitea.sha }}"

      - name: Determine changed packages
        id: changed
        env:
          ACCESS_GIT: ${{ secrets.ACCESS_GIT }}
          ACCESS_GIT_USER: ${{ secrets.ACCESS_GIT_USER }}
          REPO_OWNER: ${{ gitea.repository_owner }}
          REPO_NAME: ${{ gitea.event.repository.name }}
          RESULT_NAME: ${{ matrix.config.arch }}
        run: |
          cd extra

          base="${{ gitea.event.before }}"
          tip="${{ gitea.sha }}"

          # workflow_dispatch often has empty/zero "before". Prefer a local
          # parent commit instead of force-marking all packages changed.
          if [ -z "$base" ] || [ "$base" = "0000000000000000000000000000000000000000" ]; then
              if git rev-parse --verify "${tip}^" >/dev/null 2>&1; then
                  base="$(git rev-parse "${tip}^")"
              fi
          fi

          changed_pkgs=""
          removed_pkgs=""
          if [ -n "$base" ] && [ "$base" != "0000000000000000000000000000000000000000" ]; then
              # Collect all package names touched under srcpkgs/, including rename old/new paths.
              touched_pkgs=$(git diff --name-status "$base" "$tip" -- 'srcpkgs/*' \
                  | awk '
                      $1 ~ /^R/ {print $2; print $3; next}
                      {print $2}
                    ' \
                  | awk -F/ 'NF>=2 {print $2}' \
                  | sort -u)

              for pkg in $touched_pkgs; do
                  if [ -d "srcpkgs/$pkg" ]; then
                      changed_pkgs="$changed_pkgs $pkg"
                  else
                      removed_pkgs="$removed_pkgs $pkg"
                  fi
              done
          else
              echo "No valid base commit; changed package set will be empty unless missing-package backfill adds entries."
          fi

          changed_pkgs="${changed_pkgs#" "}"
          removed_pkgs="${removed_pkgs#" "}"

          changed_pkgs="${changed_pkgs%% }"
          removed_pkgs="${removed_pkgs%% }"

          parse_tpl_var() {
              key="$1"
              file="$2"
              awk -v key="$key" '
                  $0 ~ "^[[:space:]]*" key "=" {
                      line=$0
                      sub("^[[:space:]]*" key "=", "", line)
                      sub("[[:space:]]*#.*$", "", line)
                      if (line ~ /^"/) {
                          sub(/^"/, "", line)
                          sub(/".*$/, "", line)
                          print line
                          exit
                      }
                      if (line ~ /^'\''/) {
                          sub(/^'\''/, "", line)
                          sub(/'\''.*/, "", line)
                          print line
                          exit
                      }
                      gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
                      print line
                      exit
                  }
              ' "$file"
          }

          arch_matches_list() {
              list="$1"
              [ -z "$list" ] && return 0

              matched=0
              blocked=0
              set -f
              for token in $list; do
                  case "$token" in
                      noarch)
                          matched=1
                          ;;
                      !*)
                          pat="${token#!}"
                          case "$RESULT_NAME" in
                              $pat) blocked=1 ;;
                          esac
                          ;;
                      *)
                          case "$RESULT_NAME" in
                              $token) matched=1 ;;
                          esac
                          ;;
                  esac
              done
              set +f

              [ "$blocked" -eq 1 ] && return 1
              [ "$matched" -eq 1 ]
          }

          pkg_supports_arch() {
              pkg="$1"
              tpl="srcpkgs/${pkg}/template"
              [ -f "$tpl" ] || return 1

              only_for_archs="$(parse_tpl_var only_for_archs "$tpl")"
              arch_spec="$(parse_tpl_var archs "$tpl")"

              if [ -n "$only_for_archs" ] && ! arch_matches_list "$only_for_archs"; then
                  return 1
              fi
              if [ -n "$arch_spec" ] && ! arch_matches_list "$arch_spec"; then
                  return 1
              fi
              return 0
          }

          # Ensure packages missing from the arch repo branch are retried even
          # when templates didn't change (e.g. previously failed builds).
          all_pkgs=$(find srcpkgs -maxdepth 1 -mindepth 1 -type d -printf "%f\n" | sort -u)
          GIT_USER="${ACCESS_GIT_USER:-$REPO_OWNER}"
          BRANCH="repository-${RESULT_NAME}"
          REMOTE_PUBLIC="https://git.deadzone.lol/${REPO_OWNER}/${REPO_NAME}.git"
          REMOTE_AUTH="https://${GIT_USER}:${ACCESS_GIT}@git.deadzone.lol/${REPO_OWNER}/${REPO_NAME}.git"
          missing_pkgs=""
          outdated_pkgs=""

          if git ls-remote --exit-code --heads "$REMOTE_PUBLIC" "$BRANCH" >/dev/null 2>&1 || \
             git ls-remote --exit-code --heads "$REMOTE_AUTH" "$BRANCH" >/dev/null 2>&1; then
              BRANCH_REF="refs/remotes/repo-check/${RESULT_NAME}"
              if git fetch --no-tags --depth 1 "$REMOTE_PUBLIC" "$BRANCH:$BRANCH_REF" >/dev/null 2>&1 || \
                 git fetch --no-tags --depth 1 "$REMOTE_AUTH" "$BRANCH:$BRANCH_REF" >/dev/null 2>&1; then
                  repo_files="$(git ls-tree -r --name-only "$BRANCH_REF" || true)"
                  repo_pkgs=""
                  repo_pkgvers=""
                  for f in $repo_files; do
                      case "$f" in
                          *.${RESULT_NAME}.xbps|*.noarch.xbps)
                              base="$(basename "$f")"
                              pkgver="$(xbps-uhelper binpkgver "$base" 2>/dev/null || true)"
                              pkgname="$(xbps-uhelper getpkgname "$pkgver" 2>/dev/null || true)"
                              [ -n "$pkgname" ] && repo_pkgs="$repo_pkgs $pkgname"
                              if [ -n "$pkgname" ] && [ -n "$pkgver" ]; then
                                  repo_pkgvers="${repo_pkgvers}${pkgname} ${pkgver}\\n"
                              fi
                              ;;
                      esac
                  done
                  repo_pkgs="$(printf '%s\n' "$repo_pkgs" | tr ' ' '\n' | sed '/^$/d' | sort -u)"
                  repo_pkgvers="$(printf '%b' "$repo_pkgvers" | sed '/^$/d' | sort -u)"
                  for pkg in $all_pkgs; do
                      pkg_supports_arch "$pkg" || continue
                      tpl="srcpkgs/${pkg}/template"
                      tpl_pkgname="$(parse_tpl_var pkgname "$tpl")"
                      [ -n "$tpl_pkgname" ] || tpl_pkgname="$pkg"
                      tpl_version="$(parse_tpl_var version "$tpl")"
                      tpl_revision="$(parse_tpl_var revision "$tpl")"
                      [ -n "$tpl_revision" ] || tpl_revision="1"

                      if ! printf '%s\n' "$repo_pkgs" | grep -Fqx "$tpl_pkgname"; then
                          missing_pkgs="$missing_pkgs $pkg"
                          continue
                      fi

                      if [ -n "$tpl_version" ]; then
                          expected_pkgver="${tpl_pkgname}-${tpl_version}_${tpl_revision}"
                          if ! printf '%s\n' "$repo_pkgvers" | grep -Fqx "${tpl_pkgname} ${expected_pkgver}"; then
                              outdated_pkgs="$outdated_pkgs $pkg"
                          fi
                      fi
                  done
              else
                  echo "WARNING: failed to fetch ${BRANCH}; skipping missing-package backfill."
              fi
          else
              echo "No existing ${BRANCH}; forcing full package list for initial population."
              missing_pkgs="$all_pkgs"
          fi

          if [ -n "$missing_pkgs" ]; then
              changed_pkgs="$(printf '%s\n%s\n' "$changed_pkgs" "$missing_pkgs" \
                  | tr ' ' '\n' \
                  | sed '/^$/d' \
                  | sort -u \
                  | tr '\n' ' ')"
              changed_pkgs="${changed_pkgs%% }"
              echo "Missing in ${BRANCH}, force-build: ${missing_pkgs#" "}"
          fi

          if [ -n "$outdated_pkgs" ]; then
              changed_pkgs="$(printf '%s\n%s\n' "$changed_pkgs" "$outdated_pkgs" \
                  | tr ' ' '\n' \
                  | sed '/^$/d' \
                  | sort -u \
                  | tr '\n' ' ')"
              changed_pkgs="${changed_pkgs%% }"
              echo "Outdated in ${BRANCH}, force-build: ${outdated_pkgs#" "}"
          fi

          # Final arch filtering before expensive build setup steps.
          filtered_changed=""
          arch_skipped=""
          for pkg in $changed_pkgs; do
              if pkg_supports_arch "$pkg"; then
                  filtered_changed="$filtered_changed $pkg"
              else
                  arch_skipped="$arch_skipped $pkg"
              fi
          done
          changed_pkgs="${filtered_changed#" "}"
          changed_pkgs="${changed_pkgs%% }"
          if [ -n "$arch_skipped" ]; then
              echo "Arch-filtered out for ${RESULT_NAME}: ${arch_skipped#" "}"
          fi

          echo "Changed templates: ${changed_pkgs:-<none>}"
          echo "Removed templates: ${removed_pkgs:-<none>}"

          echo "pkgs=$changed_pkgs" >> "$GITHUB_OUTPUT"
          echo "removed=$removed_pkgs" >> "$GITHUB_OUTPUT"

      - name: Checkout void-packages
        if: ${{ steps.changed.outputs.pkgs != '' || steps.changed.outputs.removed != '' }}
        run: |
          git clone https://github.com/void-linux/void-packages.git void-packages
          cd void-packages
          git checkout --detach master

      - name: Merge templates and edit shlibs
        if: ${{ steps.changed.outputs.pkgs != '' || steps.changed.outputs.removed != '' }}
        run: |
          echo "==> copying templates..."
          cp -rv extra/srcpkgs/* void-packages/srcpkgs/

          SHLIBS_FILE="void-packages/common/shlibs"
          APPEND_FILE="extra/shlibs_append"
          REMOVE_FILE="extra/shlibs_remove"

          echo "==> updating common/shlibs..."
          if [ -f "$REMOVE_FILE" ] && [ -s "$REMOVE_FILE" ]; then
              while IFS= read -r line; do
                  [ -z "$line" ] && continue
                  grep -vF "$line" "$SHLIBS_FILE" > "$SHLIBS_FILE.tmp" && mv "$SHLIBS_FILE.tmp" "$SHLIBS_FILE"
                  echo "   - removed: $line"
              done < "$REMOVE_FILE"
          fi

          if [ -f "$APPEND_FILE" ] && [ -s "$APPEND_FILE" ]; then
              while IFS= read -r line; do
                  [ -z "$line" ] && continue
                  if ! grep -qF "$line" "$SHLIBS_FILE"; then
                      echo "$line" >> "$SHLIBS_FILE"
                      echo "   + added: $line"
                  fi
              done < "$APPEND_FILE"
          fi

      - name: Prepare masterdir
        if: ${{ steps.changed.outputs.pkgs != '' || steps.changed.outputs.removed != '' }}
        run: |
          cd void-packages
          chown -R builder:builder . &&
          sudo -Eu builder common/travis/set_mirror.sh &&
          sudo -Eu builder common/travis/prepare.sh &&
          common/travis/fetch-xtools.sh

      - name: Build
        id: build_step
        if: ${{ steps.changed.outputs.pkgs != '' || steps.changed.outputs.removed != '' }}
        run: |
          export PATH="/opt/xbps/usr/bin/:$PATH"
          cd void-packages

          changed="${{ steps.changed.outputs.pkgs }}"

          if [ -z "$changed" ]; then
              echo "No changed templates, skipping build."
              echo "built=" >> "$GITHUB_OUTPUT"
              echo "failed=" >> "$GITHUB_OUTPUT"
              exit 0
          fi

          parse_tpl_var() {
              key="$1"
              file="$2"
              awk -v key="$key" '
                  $0 ~ "^[[:space:]]*" key "=" {
                      line=$0
                      sub("^[[:space:]]*" key "=", "", line)
                      sub("[[:space:]]*#.*$", "", line)
                      if (line ~ /^"/) {
                          sub(/^"/, "", line)
                          sub(/".*$/, "", line)
                          print line
                          exit
                      }
                      if (line ~ /^'\''/) {
                          sub(/^'\''/, "", line)
                          sub(/'\''.*/, "", line)
                          print line
                          exit
                      }
                      gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
                      print line
                      exit
                  }
              ' "$file"
          }

          arch_matches_list() {
              list="$1"
              [ -z "$list" ] && return 0

              matched=0
              blocked=0
              set -f
              for token in $list; do
                  case "$token" in
                      noarch)
                          matched=1
                          ;;
                      !*)
                          pat="${token#!}"
                          case "$ARCH" in
                              $pat) blocked=1 ;;
                          esac
                          ;;
                      *)
                          case "$ARCH" in
                              $token) matched=1 ;;
                          esac
                          ;;
                  esac
              done
              set +f

              [ "$blocked" -eq 1 ] && return 1
              [ "$matched" -eq 1 ]
          }

          buildable=""
          unsupported=""
          for pkg in $changed; do
              tpl="srcpkgs/${pkg}/template"
              if [ ! -f "$tpl" ]; then
                  echo "!! missing template for ${pkg}, skipping"
                  continue
              fi

              only_for_archs="$(parse_tpl_var only_for_archs "$tpl")"
              arch_spec="$(parse_tpl_var archs "$tpl")"

              if [ -n "$only_for_archs" ] && ! arch_matches_list "$only_for_archs"; then
                  echo "   skip ${pkg}: ARCH=${ARCH} not allowed by only_for_archs=\"${only_for_archs}\""
                  unsupported="$unsupported $pkg"
                  continue
              fi

              if [ -n "$arch_spec" ] && ! arch_matches_list "$arch_spec"; then
                  echo "   skip ${pkg}: ARCH=${ARCH} not allowed by archs=\"${arch_spec}\""
                  unsupported="$unsupported $pkg"
                  continue
              fi

              buildable="$buildable $pkg"
          done

          buildable="${buildable#" "}"
          unsupported="${unsupported#" "}"
          if [ -n "$unsupported" ]; then
              echo "Skipping unsupported for ${ARCH}: $unsupported"
          fi
          if [ -z "$buildable" ]; then
              echo "No buildable packages for ${ARCH} after arch filtering."
              echo "built=" >> "$GITHUB_OUTPUT"
              echo "failed=" >> "$GITHUB_OUTPUT"
              exit 0
          fi

          if [ "$BOOTSTRAP" != "$ARCH" ]; then
              arch="-a $ARCH"
          fi

          if [ "$TEST" = 1 ]; then
              test="-Q"
          fi

          PKGS=$(sudo -Eu builder ./xbps-src $test sort-dependencies $buildable)
          built=""
          failed=""

          for pkg in ${PKGS}; do
              if sudo -Eu builder ./xbps-src -j"$(nproc)" -s $arch $test pkg "${pkg}"; then
                  built="$built $pkg"
              else
                  echo "!! build failed for ${pkg}"
                  failed="$failed $pkg"
              fi
          done

          built="${built#" "}"
          failed="${failed#" "}"

          echo "Built packages: ${built:-<none>}"
          echo "Failed packages: ${failed:-<none>}"

          echo "built=$built" >> "$GITHUB_OUTPUT"
          echo "failed=$failed" >> "$GITHUB_OUTPUT"

      - name: Write failed list into repo branch
        if: ${{ steps.build_step.outputs.failed != '' }}
        env:
          ACCESS_GIT: ${{ secrets.ACCESS_GIT }}
          ACCESS_GIT_USER: ${{ secrets.ACCESS_GIT_USER }}
          REPO_OWNER: ${{ gitea.repository_owner }}
          REPO_NAME: ${{ gitea.event.repository.name }}
          RESULT_NAME: ${{ matrix.config.arch }}
        run: |
          set -e
          cd extra
          git config user.name "gitea-actions[bot]"
          git config user.email "gitea-actions[bot]@noreply.deadzone.lol"

          GIT_USER="${ACCESS_GIT_USER:-$REPO_OWNER}"
          BRANCH="repository-${RESULT_NAME}"
          REMOTE="https://$GIT_USER:${ACCESS_GIT}@git.deadzone.lol/${REPO_OWNER}/${REPO_NAME}.git"

          if git ls-remote --exit-code --heads "$REMOTE" "$BRANCH" >/dev/null 2>&1; then
              git fetch "$REMOTE" "$BRANCH:$BRANCH"
              git checkout "$BRANCH"
          else
              git checkout --orphan "$BRANCH"
              find . -mindepth 1 -maxdepth 1 ! -name .git -exec rm -rf {} +
          fi

          echo "${{ steps.build_step.outputs.failed }}" | tr ' ' '\n' > build-failures-${{ matrix.config.arch }}.txt

          git add build-failures-${{ matrix.config.arch }}.txt
          if git diff --cached --quiet; then
              echo "No changes to push for failures file."
          else
              failed_csv=$(printf '%s\n' "${{ steps.build_step.outputs.failed }}" | tr ' ' ',' | sed -e 's/^,*//' -e 's/,*$//')
              if [ -n "$failed_csv" ]; then
                  git commit -m "build(${RESULT_NAME}): failed ${failed_csv}"
              else
                  git commit -m "build(${RESULT_NAME}): update failures list"
              fi
              git push "$REMOTE" "$BRANCH"
          fi

      - name: Sign
        if: ${{ steps.build_step.outputs.built != '' || steps.changed.outputs.removed != '' }}
        env:
          PRIV_KEY: ${{ secrets.PRIV_KEY }}
          XBPS_ARCH: ${{ matrix.config.arch }}
          ACCESS_GIT: ${{ secrets.ACCESS_GIT }}
          ACCESS_GIT_USER: ${{ secrets.ACCESS_GIT_USER }}
          REPO_OWNER: ${{ gitea.repository_owner }}
          REPO_NAME: ${{ gitea.event.repository.name }}
          RESULT_NAME: ${{ matrix.config.arch }}
        working-directory: void-packages/hostdir/binpkgs/
        run: |
          set -e
          export PATH="/opt/xbps/usr/bin/:$PATH"

          mkdir -p /tmp/newpkgs
          # Collect only this arch + noarch packages from top-level/subdirs.
          find . -maxdepth 2 -type f \( -name "*.${RESULT_NAME}.xbps" -o -name "*.noarch.xbps" \) \
              -exec cp -v {} /tmp/newpkgs/ \;
          find . -maxdepth 2 -type f \
              \( -name "*.${RESULT_NAME}.xbps.sig" -o -name "*.noarch.xbps.sig" -o \
                 -name "*.${RESULT_NAME}.xbps.sig2" -o -name "*.noarch.xbps.sig2" \) \
              -exec cp -v {} /tmp/newpkgs/ \;

          GIT_USER="${ACCESS_GIT_USER:-$REPO_OWNER}"
          BRANCH="repository-${RESULT_NAME}"
          REMOTE="https://$GIT_USER:${ACCESS_GIT}@git.deadzone.lol/${REPO_OWNER}/${REPO_NAME}.git"
          mkdir -p /tmp/oldrepo

          # Clean everything including subdirs like nonfree/
          rm -rf ./*

          if git ls-remote --exit-code --heads "$REMOTE" "$BRANCH" >/dev/null 2>&1; then
              git clone --depth 1 --branch "$BRANCH" "$REMOTE" /tmp/oldrepo
              cp -v /tmp/oldrepo/*.${RESULT_NAME}.xbps . 2>/dev/null || true
              cp -v /tmp/oldrepo/*.noarch.xbps . 2>/dev/null || true
              cp -v /tmp/oldrepo/*.${RESULT_NAME}.xbps.sig . 2>/dev/null || true
              cp -v /tmp/oldrepo/*.noarch.xbps.sig . 2>/dev/null || true
              cp -v /tmp/oldrepo/*.${RESULT_NAME}.xbps.sig2 . 2>/dev/null || true
              cp -v /tmp/oldrepo/*.noarch.xbps.sig2 . 2>/dev/null || true
          else
              echo "No existing $BRANCH on remote, starting fresh."
          fi

          new_pkg_files=""
          for f in /tmp/newpkgs/*.xbps; do
              [ -e "$f" ] || continue
              base=$(basename "$f")
              pkgver=$(xbps-uhelper binpkgver "$base" 2>/dev/null || true)
              pkgname=$(xbps-uhelper getpkgname "$pkgver" 2>/dev/null || true)
              if [ -z "$pkgname" ]; then
                  echo "WARNING: failed to parse pkgname from $base, skipping old-version cleanup for this file."
                  new_pkg_files="$new_pkg_files ./${base}"
                  continue
              fi
              rm -f "${pkgname}-"*.${RESULT_NAME}.xbps "${pkgname}-"*.noarch.xbps \
                    "${pkgname}-"*.${RESULT_NAME}.xbps.sig "${pkgname}-"*.noarch.xbps.sig \
                    "${pkgname}-"*.${RESULT_NAME}.xbps.sig2 "${pkgname}-"*.noarch.xbps.sig2 \
                    2>/dev/null || true
              new_pkg_files="$new_pkg_files ./${base}"
          done

          removed="${{ steps.changed.outputs.removed }}"
          if [ -n "$removed" ]; then
              echo "==> removing packages for deleted templates..."
              for pkg in $removed; do
                  rm -f "${pkg}-"*.${RESULT_NAME}.xbps "${pkg}-"*.noarch.xbps \
                        "${pkg}-"*.${RESULT_NAME}.xbps.sig "${pkg}-"*.noarch.xbps.sig \
                        "${pkg}-"*.${RESULT_NAME}.xbps.sig2 "${pkg}-"*.noarch.xbps.sig2 \
                        2>/dev/null || true
                  rm -f "${pkg}.${RESULT_NAME}.xbps" "${pkg}.noarch.xbps" \
                        "${pkg}.${RESULT_NAME}.xbps.sig" "${pkg}.noarch.xbps.sig" \
                        "${pkg}.${RESULT_NAME}.xbps.sig2" "${pkg}.noarch.xbps.sig2" \
                        2>/dev/null || true
              done
          fi

          cp -v /tmp/newpkgs/* . 2>/dev/null || true

          set -- ./*.xbps
          if [ ! -e "$1" ]; then
              echo "No .xbps packages to sign for ${RESULT_NAME}; skipping."
              rm -f index* ./*-repodata 2>/dev/null || true
              exit 0
          fi

          printf "%s\n" "$PRIV_KEY" > private.pem
          chmod 600 private.pem

          # Rebuild metadata from all currently present packages so one-package
          # updates never prune unrelated packages from the repo branch.
          rm -f index* ./*-repodata 2>/dev/null || true
          all_pkg_files=""
          for f in ./*.xbps; do
              [ -e "$f" ] || continue
              all_pkg_files="$all_pkg_files $f"
          done
          # Intentionally expanded as a file list.
          xbps-rindex -a $all_pkg_files
          xbps-rindex -s --signedby "void-repo <noreply@deadzone.lol>" --privkey private.pem "$PWD"
          if [ -n "$new_pkg_files" ]; then
              # Intentionally expanded as a file list.
              xbps-rindex -S --privkey private.pem $new_pkg_files
          fi
          xbps-rindex -c "$PWD"

          rm -f private.pem

      - name: Push binpkgs branch (per arch)
        if: ${{ steps.build_step.outputs.built != '' || steps.changed.outputs.removed != '' }}
        env:
          REPO_OWNER: ${{ gitea.repository_owner }}
          REPO_NAME: ${{ gitea.event.repository.name }}
          ACCESS_GIT: ${{ secrets.ACCESS_GIT }}
          ACCESS_GIT_USER: ${{ secrets.ACCESS_GIT_USER }}
          RESULT_NAME: ${{ matrix.config.arch }}
        run: |
          set -e
          cd extra
          git config user.name "gitea-actions[bot]"
          git config user.email "gitea-actions[bot]@noreply.deadzone.lol"

          GIT_USER="${ACCESS_GIT_USER:-$REPO_OWNER}"
          BRANCH="repository-${RESULT_NAME}"
          REMOTE="https://$GIT_USER:${ACCESS_GIT}@git.deadzone.lol/${REPO_OWNER}/${REPO_NAME}.git"
          LFS_URL="https://git.deadzone.lol/${REPO_OWNER}/${REPO_NAME}.git/info/lfs"

          git config --local credential.helper store
          git config --local credential.useHttpPath false
          for key in $(git config --local --name-only --get-regexp '^http\\..*\\.extraheader$' 2>/dev/null || true); do
              git config --local --unset-all "$key" || true
          done
          for key in $(git config --global --name-only --get-regexp '^http\\..*\\.extraheader$' 2>/dev/null || true); do
              git config --global --unset-all "$key" || true
          done

          git config --local --unset-all lfs.url 2>/dev/null || true
          git config --local --unset-all "lfs.${LFS_URL}.access" 2>/dev/null || true
          git config --local lfs.locksverify false
          git config --local "lfs.${LFS_URL}.locksverify" false
          # Prefer conservative transfer settings to reduce proxy/stream interruptions.
          git config --local http.version HTTP/1.1
          git config --local lfs.concurrenttransfers 1
          git config --local lfs.basictransfersonly true
          git config --local lfs.transfer.maxretries 10
          git config --local lfs.transfer.maxretrydelay 30
          git lfs install --local

          # Snapshot-only branch: recreate branch from scratch every run.
          if git show-ref --verify --quiet "refs/heads/${BRANCH}"; then
              current_branch="$(git symbolic-ref --short -q HEAD || true)"
              if [ "$current_branch" = "$BRANCH" ]; then
                  git checkout --detach
              fi
              git branch -D "$BRANCH" || true
          fi
          git checkout --orphan "$BRANCH"
          git reset --hard

          mkdir -p /tmp/failfiles
          cp build-failures-* /tmp/failfiles/ 2>/dev/null || true

          find . -mindepth 1 -maxdepth 1 ! -name .git -exec rm -rf {} +

          # Copy only this arch + noarch artifacts (flatten from subdirs like nonfree/)
          find ../void-packages/hostdir/binpkgs/ -maxdepth 2 -type f \
              \( -name "*.${RESULT_NAME}.xbps" -o -name "*.noarch.xbps" \) \
              -exec cp -v {} . \;
          find ../void-packages/hostdir/binpkgs/ -maxdepth 2 -type f \
              \( -name "*.${RESULT_NAME}.xbps.sig" -o -name "*.noarch.xbps.sig" \) \
              -exec cp -v {} . \;
          find ../void-packages/hostdir/binpkgs/ -maxdepth 2 -type f \
              \( -name "*.${RESULT_NAME}.xbps.sig2" -o -name "*.noarch.xbps.sig2" \) \
              -exec cp -v {} . \;
          cp ../void-packages/hostdir/binpkgs/${RESULT_NAME}-repodata . 2>/dev/null || true

          cp /tmp/failfiles/* . 2>/dev/null || true

          # Enable LFS for .xbps files on this branch
          printf '*.xbps filter=lfs diff=lfs merge=lfs -text\n' > .gitattributes

          commit_count=0

          push_with_retry() {
              pushed=0
              for attempt in 1 2 3; do
                  if git push --force "$REMOTE" "$BRANCH"; then
                      pushed=1
                      break
                  fi
                  if [ "$attempt" -lt 3 ]; then
                      delay=$((attempt * 15))
                      echo "Push failed (attempt ${attempt}/3), retrying in ${delay}s..."
                      sleep "$delay"
                  fi
              done
              if [ "$pushed" -ne 1 ]; then
                  echo "Push failed after 3 attempts."
                  return 1
              fi
          }

          # Create one commit per changed package binary for easier history/debugging.
          for f in ./*.xbps; do
              [ -e "$f" ] || continue
              base=$(basename "$f")
              pkgver=$(xbps-uhelper binpkgver "$base" 2>/dev/null || true)
              pkgname=$(xbps-uhelper getpkgname "$pkgver" 2>/dev/null || true)

              git add -A -- "$f"
              for p in "${f%.xbps}.xbps.sig" "${f%.xbps}.xbps.sig2"; do
                  [ -e "$p" ] || continue
                  git add -A -- "$p"
              done

              if git diff --cached --quiet; then
                  continue
              fi

              if [ -n "$pkgver" ]; then
                  git commit -m "binpkg(${RESULT_NAME}): update ${pkgver}"
              elif [ -n "$pkgname" ]; then
                  git commit -m "binpkg(${RESULT_NAME}): update ${pkgname}"
              else
                  git commit -m "binpkg(${RESULT_NAME}): update ${base%.xbps}"
              fi
              commit_count=$((commit_count + 1))

              # Push each package commit immediately to keep LFS uploads smaller.
              push_with_retry
          done

          # Commit repository metadata and any non-binary leftovers.
          git add -A
          if ! git diff --cached --quiet; then
              git commit -m "binpkg(${RESULT_NAME}): refresh metadata"
              commit_count=$((commit_count + 1))
              push_with_retry
          fi

          if [ "$commit_count" -eq 0 ]; then
              echo "No changes to push."
              exit 0
          fi
