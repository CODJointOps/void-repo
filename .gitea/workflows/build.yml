name: build

on:
  push:
    branches:
      - master
    paths:
      - 'srcpkgs/**'
  workflow_dispatch:

jobs:
  build:
    name: Build packages
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/void-linux/void-${{ matrix.config.libc }}-full:20250616R1
      options: --privileged
      volumes:
        - /dev:/dev
      env:
        ARCH: '${{ matrix.config.arch }}'
        BOOTSTRAP: '${{ matrix.config.host }}'
        TEST: '${{ matrix.config.test }}'
    strategy:
      fail-fast: false
      matrix:
        config:
          - { arch: x86_64,       host: x86_64,      libc: glibc, test: 1 }
          - { arch: aarch64,      host: x86_64,      libc: glibc, test: 0 }
          - { arch: x86_64-musl,  host: x86_64-musl, libc: musl,  test: 1 }
          - { arch: aarch64-musl, host: x86_64-musl, libc: musl,  test: 0 }

    permissions:
      contents: write

    steps:
      - name: Prepare container
        run: |
          mkdir -p /etc/xbps.d && cp /usr/share/xbps.d/*-repository-*.conf /etc/xbps.d/
          sed -i 's|repo-default|repo-ci|g' /etc/xbps.d/*-repository-*.conf
          xbps-install -Syu xbps && xbps-install -yu && xbps-install -y sudo bash curl git git-lfs
          useradd -G xbuilder -M builder

      - name: Configure git credentials for LFS
        env:
          ACCESS_GIT: ${{ secrets.ACCESS_GIT }}
          ACCESS_GIT_USER: ${{ secrets.ACCESS_GIT_USER }}
          REPO_OWNER: ${{ gitea.repository_owner }}
          REPO_FULL: ${{ gitea.repository }}
        run: |
          GIT_USER="${ACCESS_GIT_USER:-$REPO_OWNER}"
          printf "%s\n" \
            "https://${GIT_USER}:${ACCESS_GIT}@git.deadzone.lol/${REPO_FULL}.git" \
            "https://${GIT_USER}:${ACCESS_GIT}@git.deadzone.lol" > ~/.git-credentials
          git config --global credential.helper store
          git config --global credential.useHttpPath false
          for key in $(git config --global --name-only --get-regexp '^http\\..*\\.extraheader$' 2>/dev/null || true); do
              git config --global --unset-all "$key" || true
          done
          git lfs install

      - name: Checkout this repo
        env:
          ACCESS_GIT: ${{ secrets.ACCESS_GIT }}
          ACCESS_GIT_USER: ${{ secrets.ACCESS_GIT_USER }}
          REPO_OWNER: ${{ gitea.repository_owner }}
        run: |
          GIT_USER="${ACCESS_GIT_USER:-$REPO_OWNER}"
          REMOTE_PUBLIC="https://git.deadzone.lol/${{ gitea.repository }}.git"
          REMOTE_AUTH="https://${GIT_USER}:${ACCESS_GIT}@git.deadzone.lol/${{ gitea.repository }}.git"

          cloned=0
          for attempt in 1 2 3; do
              rm -rf extra
              # Public repo: prefer unauthenticated clone, fall back to token auth.
              if git clone --depth 1 "$REMOTE_PUBLIC" extra; then
                  cloned=1
                  break
              fi
              rm -rf extra
              if git clone --depth 1 "$REMOTE_AUTH" extra; then
                  cloned=1
                  break
              fi
              if [ "$attempt" -lt 3 ]; then
                  delay=$((attempt * 10))
                  echo "Checkout failed (attempt ${attempt}/3), retrying in ${delay}s..."
                  sleep "$delay"
              fi
          done
          if [ "$cloned" -ne 1 ]; then
              echo "Checkout failed after 3 attempts."
              exit 1
          fi

          cd extra
          git remote set-url origin "$REMOTE_PUBLIC"
          if [ -n "${{ gitea.event.before }}" ] && [ "${{ gitea.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              git fetch --no-tags "$REMOTE_PUBLIC" "${{ gitea.event.before }}" --depth 1 \
                  || git fetch --no-tags "$REMOTE_AUTH" "${{ gitea.event.before }}" --depth 1 \
                  || true
          fi
          git fetch --no-tags "$REMOTE_PUBLIC" "${{ gitea.sha }}" --depth 1 \
              || git fetch --no-tags "$REMOTE_AUTH" "${{ gitea.sha }}" --depth 1
          git checkout --detach "${{ gitea.sha }}"

      - name: Determine changed packages
        id: changed
        run: |
          cd extra

          base="${{ gitea.event.before }}"
          tip="${{ gitea.sha }}"

          if [ -z "$base" ] || [ "$base" = "0000000000000000000000000000000000000000" ]; then
              changed_pkgs=$(find srcpkgs -maxdepth 1 -mindepth 1 -type d -printf "%f\n" \
                | tr '\n' ' ')
              removed_pkgs=""
          else
              # Collect all package names touched under srcpkgs/, including rename old/new paths.
              touched_pkgs=$(git diff --name-status "$base" "$tip" -- 'srcpkgs/*' \
                  | awk '
                      $1 ~ /^R/ {print $2; print $3; next}
                      {print $2}
                    ' \
                  | awk -F/ 'NF>=2 {print $2}' \
                  | sort -u)

              changed_pkgs=""
              removed_pkgs=""
              for pkg in $touched_pkgs; do
                  if [ -d "srcpkgs/$pkg" ]; then
                      changed_pkgs="$changed_pkgs $pkg"
                  else
                      removed_pkgs="$removed_pkgs $pkg"
                  fi
              done

              changed_pkgs="${changed_pkgs#" "}"
              removed_pkgs="${removed_pkgs#" "}"
          fi

          changed_pkgs="${changed_pkgs%% }"
          removed_pkgs="${removed_pkgs%% }"

          echo "Changed templates: ${changed_pkgs:-<none>}"
          echo "Removed templates: ${removed_pkgs:-<none>}"

          echo "pkgs=$changed_pkgs" >> "$GITHUB_OUTPUT"
          echo "removed=$removed_pkgs" >> "$GITHUB_OUTPUT"

      - name: Checkout void-packages
        run: |
          git clone https://github.com/void-linux/void-packages.git void-packages
          cd void-packages
          git checkout --detach master

      - name: Merge templates and edit shlibs
        run: |
          echo "==> copying templates..."
          cp -rv extra/srcpkgs/* void-packages/srcpkgs/

          SHLIBS_FILE="void-packages/common/shlibs"
          APPEND_FILE="extra/shlibs_append"
          REMOVE_FILE="extra/shlibs_remove"

          echo "==> updating common/shlibs..."
          if [ -f "$REMOVE_FILE" ] && [ -s "$REMOVE_FILE" ]; then
              while IFS= read -r line; do
                  [ -z "$line" ] && continue
                  grep -vF "$line" "$SHLIBS_FILE" > "$SHLIBS_FILE.tmp" && mv "$SHLIBS_FILE.tmp" "$SHLIBS_FILE"
                  echo "   - removed: $line"
              done < "$REMOVE_FILE"
          fi

          if [ -f "$APPEND_FILE" ] && [ -s "$APPEND_FILE" ]; then
              while IFS= read -r line; do
                  [ -z "$line" ] && continue
                  if ! grep -qF "$line" "$SHLIBS_FILE"; then
                      echo "$line" >> "$SHLIBS_FILE"
                      echo "   + added: $line"
                  fi
              done < "$APPEND_FILE"
          fi

      - name: Prepare masterdir
        run: |
          cd void-packages
          chown -R builder:builder . &&
          sudo -Eu builder common/travis/set_mirror.sh &&
          sudo -Eu builder common/travis/prepare.sh &&
          common/travis/fetch-xtools.sh

      - name: Build
        id: build_step
        run: |
          export PATH="/opt/xbps/usr/bin/:$PATH"
          cd void-packages

          changed="${{ steps.changed.outputs.pkgs }}"

          if [ -z "$changed" ]; then
              echo "No changed templates, skipping build."
              echo "built=" >> "$GITHUB_OUTPUT"
              echo "failed=" >> "$GITHUB_OUTPUT"
              exit 0
          fi

          buildable=""
          unsupported=""
          for pkg in $changed; do
              tpl="srcpkgs/${pkg}/template"
              if [ ! -f "$tpl" ]; then
                  echo "!! missing template for ${pkg}, skipping"
                  continue
              fi

              arch_spec="$(sed -n 's/^archs=\"\\(.*\\)\"/\\1/p' "$tpl" | head -n1)"
              if [ -z "$arch_spec" ]; then
                  buildable="$buildable $pkg"
                  continue
              fi

              supported=0
              blocked=0
              # Treat arch tokens as patterns (e.g. x86_64*) instead of filesystem globs.
              set -f
              for token in $arch_spec; do
                  case "$token" in
                      noarch)
                          supported=1
                          ;;
                      !*)
                          pat="${token#!}"
                          case "$ARCH" in
                              $pat) blocked=1 ;;
                          esac
                          ;;
                      *)
                          case "$ARCH" in
                              $token) supported=1 ;;
                          esac
                          ;;
                  esac
              done
              set +f

              if [ "$blocked" -eq 1 ]; then
                  supported=0
              fi

              if [ "$supported" -eq 1 ]; then
                  buildable="$buildable $pkg"
              else
                  unsupported="$unsupported $pkg"
              fi
          done

          buildable="${buildable#" "}"
          unsupported="${unsupported#" "}"
          if [ -n "$unsupported" ]; then
              echo "Skipping unsupported for ${ARCH}: $unsupported"
          fi
          if [ -z "$buildable" ]; then
              echo "No buildable packages for ${ARCH} after arch filtering."
              echo "built=" >> "$GITHUB_OUTPUT"
              echo "failed=" >> "$GITHUB_OUTPUT"
              exit 0
          fi

          if [ "$BOOTSTRAP" != "$ARCH" ]; then
              arch="-a $ARCH"
          fi

          if [ "$TEST" = 1 ]; then
              test="-Q"
          fi

          PKGS=$(sudo -Eu builder ./xbps-src $test sort-dependencies $buildable)
          built=""
          failed=""

          for pkg in ${PKGS}; do
              if sudo -Eu builder ./xbps-src -j"$(nproc)" -s $arch $test pkg "${pkg}"; then
                  built="$built $pkg"
              else
                  echo "!! build failed for ${pkg}"
                  failed="$failed $pkg"
              fi
          done

          built="${built#" "}"
          failed="${failed#" "}"

          echo "Built packages: ${built:-<none>}"
          echo "Failed packages: ${failed:-<none>}"

          echo "built=$built" >> "$GITHUB_OUTPUT"
          echo "failed=$failed" >> "$GITHUB_OUTPUT"

      - name: Write failed list into repo branch
        if: ${{ steps.build_step.outputs.failed != '' }}
        env:
          ACCESS_GIT: ${{ secrets.ACCESS_GIT }}
          ACCESS_GIT_USER: ${{ secrets.ACCESS_GIT_USER }}
          REPO_OWNER: ${{ gitea.repository_owner }}
          REPO_NAME: ${{ gitea.event.repository.name }}
          RESULT_NAME: ${{ matrix.config.arch }}
        run: |
          set -e
          cd extra
          git config user.name "gitea-actions[bot]"
          git config user.email "gitea-actions[bot]@noreply.deadzone.lol"

          GIT_USER="${ACCESS_GIT_USER:-$REPO_OWNER}"
          BRANCH="repository-${RESULT_NAME}"
          REMOTE="https://$GIT_USER:${ACCESS_GIT}@git.deadzone.lol/${REPO_OWNER}/${REPO_NAME}.git"

          if git ls-remote --exit-code --heads "$REMOTE" "$BRANCH" >/dev/null 2>&1; then
              git fetch "$REMOTE" "$BRANCH:$BRANCH"
              git checkout "$BRANCH"
          else
              git checkout --orphan "$BRANCH"
              find . -mindepth 1 -maxdepth 1 ! -name .git -exec rm -rf {} +
          fi

          echo "${{ steps.build_step.outputs.failed }}" | tr ' ' '\n' > build-failures-${{ matrix.config.arch }}.txt

          git add build-failures-${{ matrix.config.arch }}.txt
          if git diff --cached --quiet; then
              echo "No changes to push for failures file."
          else
              failed_csv=$(printf '%s\n' "${{ steps.build_step.outputs.failed }}" | tr ' ' ',' | sed -e 's/^,*//' -e 's/,*$//')
              if [ -n "$failed_csv" ]; then
                  git commit -m "build(${RESULT_NAME}): failed ${failed_csv}"
              else
                  git commit -m "build(${RESULT_NAME}): update failures list"
              fi
              git push "$REMOTE" "$BRANCH"
          fi

      - name: Sign
        if: ${{ steps.build_step.outputs.built != '' || steps.changed.outputs.removed != '' }}
        env:
          PRIV_KEY: ${{ secrets.PRIV_KEY }}
          XBPS_ARCH: ${{ matrix.config.arch }}
          ACCESS_GIT: ${{ secrets.ACCESS_GIT }}
          ACCESS_GIT_USER: ${{ secrets.ACCESS_GIT_USER }}
          REPO_OWNER: ${{ gitea.repository_owner }}
          REPO_NAME: ${{ gitea.event.repository.name }}
          RESULT_NAME: ${{ matrix.config.arch }}
        working-directory: void-packages/hostdir/binpkgs/
        run: |
          set -e
          export PATH="/opt/xbps/usr/bin/:$PATH"

          mkdir -p /tmp/newpkgs
          # Collect all .xbps from top-level and subdirs (e.g. nonfree/)
          find . -name '*.xbps' -exec cp -v {} /tmp/newpkgs/ \;
          find . -name '*.xbps.sig' -exec cp -v {} /tmp/newpkgs/ \;

          GIT_USER="${ACCESS_GIT_USER:-$REPO_OWNER}"
          BRANCH="repository-${RESULT_NAME}"
          REMOTE="https://$GIT_USER:${ACCESS_GIT}@git.deadzone.lol/${REPO_OWNER}/${REPO_NAME}.git"
          mkdir -p /tmp/oldrepo

          # Clean everything including subdirs like nonfree/
          rm -rf ./*

          if git ls-remote --exit-code --heads "$REMOTE" "$BRANCH" >/dev/null 2>&1; then
              git clone --depth 1 --branch "$BRANCH" "$REMOTE" /tmp/oldrepo
              cp -v /tmp/oldrepo/*.xbps . 2>/dev/null || true
              cp -v /tmp/oldrepo/*.xbps.sig . 2>/dev/null || true
              cp -v /tmp/oldrepo/*.xbps.sig2 . 2>/dev/null || true
              cp -v /tmp/oldrepo/index* . 2>/dev/null || true
          else
              echo "No existing $BRANCH on remote, starting fresh."
          fi

          new_pkg_files=""
          for f in /tmp/newpkgs/*.xbps; do
              [ -e "$f" ] || continue
              base=$(basename "$f")
              pkgver=$(xbps-uhelper binpkgver "$base" 2>/dev/null || true)
              pkgname=$(xbps-uhelper getpkgname "$pkgver" 2>/dev/null || true)
              if [ -z "$pkgname" ]; then
                  echo "WARNING: failed to parse pkgname from $base, skipping old-version cleanup for this file."
                  new_pkg_files="$new_pkg_files ./${base}"
                  continue
              fi
              rm -f "${pkgname}-"*.xbps "${pkgname}-"*.xbps.sig "${pkgname}-"*.xbps.sig2 2>/dev/null || true
              new_pkg_files="$new_pkg_files ./${base}"
          done

          removed="${{ steps.changed.outputs.removed }}"
          if [ -n "$removed" ]; then
              echo "==> removing packages for deleted templates..."
              for pkg in $removed; do
                  rm -f "${pkg}-"*.xbps "${pkg}-"*.xbps.sig "${pkg}-"*.xbps.sig2 2>/dev/null || true
                  rm -f "${pkg}.xbps" "${pkg}.xbps.sig" "${pkg}.xbps.sig2" 2>/dev/null || true
              done
          fi

          cp -v /tmp/newpkgs/* . 2>/dev/null || true

          set -- ./*.xbps
          if [ ! -e "$1" ]; then
              echo "No .xbps packages to sign for ${RESULT_NAME}; skipping."
              rm -f index* 2>/dev/null || true
              exit 0
          fi

          printf "%s\n" "$PRIV_KEY" > private.pem
          chmod 600 private.pem

          if [ -n "$new_pkg_files" ]; then
              xbps-rindex -a $new_pkg_files || true
          else
              echo "No new .xbps files; refreshing repository metadata only."
          fi
          xbps-rindex -r "$PWD"
          xbps-rindex -s --signedby "void-repo <noreply@deadzone.lol>" --privkey private.pem "$PWD"
          if [ -n "$new_pkg_files" ]; then
              xbps-rindex -S --privkey private.pem $new_pkg_files
          fi
          xbps-rindex -c "$PWD"

          rm -f private.pem

      - name: Push binpkgs branch (per arch)
        if: ${{ steps.build_step.outputs.built != '' || steps.changed.outputs.removed != '' }}
        env:
          REPO_OWNER: ${{ gitea.repository_owner }}
          REPO_NAME: ${{ gitea.event.repository.name }}
          ACCESS_GIT: ${{ secrets.ACCESS_GIT }}
          ACCESS_GIT_USER: ${{ secrets.ACCESS_GIT_USER }}
          RESULT_NAME: ${{ matrix.config.arch }}
        run: |
          set -e
          cd extra
          git config user.name "gitea-actions[bot]"
          git config user.email "gitea-actions[bot]@noreply.deadzone.lol"

          GIT_USER="${ACCESS_GIT_USER:-$REPO_OWNER}"
          BRANCH="repository-${RESULT_NAME}"
          REMOTE="https://$GIT_USER:${ACCESS_GIT}@git.deadzone.lol/${REPO_OWNER}/${REPO_NAME}.git"
          LFS_URL="https://git.deadzone.lol/${REPO_OWNER}/${REPO_NAME}.git/info/lfs"

          git config --local credential.helper store
          git config --local credential.useHttpPath false
          for key in $(git config --local --name-only --get-regexp '^http\\..*\\.extraheader$' 2>/dev/null || true); do
              git config --local --unset-all "$key" || true
          done
          for key in $(git config --global --name-only --get-regexp '^http\\..*\\.extraheader$' 2>/dev/null || true); do
              git config --global --unset-all "$key" || true
          done

          git config --local --unset-all lfs.url 2>/dev/null || true
          git config --local --unset-all "lfs.${LFS_URL}.access" 2>/dev/null || true
          git config --local "lfs.${LFS_URL}.locksverify" false
          # Prefer conservative transfer settings to reduce proxy/stream interruptions.
          git config --local http.version HTTP/1.1
          git config --local lfs.concurrenttransfers 1
          git config --local lfs.basictransfersonly true
          git config --local lfs.transfer.maxretries 10
          git config --local lfs.transfer.maxretrydelay 30
          git lfs install --local

          if git ls-remote --exit-code --heads "$REMOTE" "$BRANCH" >/dev/null 2>&1; then
              git fetch "$REMOTE" "$BRANCH"
              git checkout -B "$BRANCH" FETCH_HEAD
          else
              git checkout --orphan "$BRANCH"
          fi

          mkdir -p /tmp/failfiles
          cp build-failures-* /tmp/failfiles/ 2>/dev/null || true

          find . -mindepth 1 -maxdepth 1 ! -name .git -exec rm -rf {} +

          # Copy all .xbps and related files (flatten from subdirs like nonfree/)
          find ../void-packages/hostdir/binpkgs/ -maxdepth 2 -name '*.xbps' -exec cp -v {} . \;
          find ../void-packages/hostdir/binpkgs/ -maxdepth 2 -name '*.xbps.sig' -exec cp -v {} . \;
          find ../void-packages/hostdir/binpkgs/ -maxdepth 2 -name '*.xbps.sig2' -exec cp -v {} . \;
          cp ../void-packages/hostdir/binpkgs/*-repodata . 2>/dev/null || true

          cp /tmp/failfiles/* . 2>/dev/null || true

          # Enable LFS for .xbps files on this branch
          printf '*.xbps filter=lfs diff=lfs merge=lfs -text\n' > .gitattributes

          commit_count=0

          # Create one commit per changed package binary for easier history/debugging.
          for f in ./*.xbps; do
              [ -e "$f" ] || continue
              base=$(basename "$f")
              pkgver=$(xbps-uhelper binpkgver "$base" 2>/dev/null || true)
              pkgname=$(xbps-uhelper getpkgname "$pkgver" 2>/dev/null || true)

              git add -A -- "$f"
              for p in "${f%.xbps}.xbps.sig" "${f%.xbps}.xbps.sig2"; do
                  [ -e "$p" ] || continue
                  git add -A -- "$p"
              done

              if git diff --cached --quiet; then
                  continue
              fi

              if [ -n "$pkgver" ]; then
                  git commit -m "binpkg(${RESULT_NAME}): update ${pkgver}"
              elif [ -n "$pkgname" ]; then
                  git commit -m "binpkg(${RESULT_NAME}): update ${pkgname}"
              else
                  git commit -m "binpkg(${RESULT_NAME}): update ${base%.xbps}"
              fi
              commit_count=$((commit_count + 1))
          done

          # Commit repository metadata and any non-binary leftovers.
          git add -A
          if ! git diff --cached --quiet; then
              git commit -m "binpkg(${RESULT_NAME}): refresh metadata"
              commit_count=$((commit_count + 1))
          fi

          if [ "$commit_count" -eq 0 ]; then
              echo "No changes to push."
              exit 0
          fi

          pushed=0
          for attempt in 1 2 3; do
              if git push "$REMOTE" "$BRANCH"; then
                  pushed=1
                  break
              fi
              if [ "$attempt" -lt 3 ]; then
                  delay=$((attempt * 15))
                  echo "Push failed (attempt ${attempt}/3), retrying in ${delay}s..."
                  sleep "$delay"
              fi
          done

          if [ "$pushed" -ne 1 ]; then
              echo "Push failed after 3 attempts."
              exit 1
          fi
