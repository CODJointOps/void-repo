name: sync

on:
  schedule:
    - cron: '10 12 * * *'
  workflow_dispatch:

jobs:
  sync:
    name: Sync package templates
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.ACCESS_GIT }}

      - name: Sync templates from package repos
        env:
          ACCESS_GIT: ${{ secrets.ACCESS_GIT }}
        run: |
          set -e
          changed=false
          managed_file=$(mktemp)
          trap 'rm -f "$managed_file"' EXIT

          sync_one_pkg() {
              pkgname="$1"
              srcdir="$2"

              if [ ! -f "$srcdir/template" ]; then
                  echo "   WARNING: missing template for $pkgname in $srcdir, skipping"
                  return
              fi

              printf '%s\n' "$pkgname" >> "$managed_file"
              if [ ! -e "srcpkgs/$pkgname" ] && [ ! -L "srcpkgs/$pkgname" ]; then
                  mkdir -p "srcpkgs/$pkgname"
              fi

              if diff -rq --exclude='.git' --exclude='.gitea' --exclude='README.md' "$srcdir/" "srcpkgs/$pkgname/" >/dev/null 2>&1; then
                  echo "   No changes for $pkgname"
              else
                  rm -rf "srcpkgs/$pkgname"
                  mkdir -p "srcpkgs/$pkgname"
                  # Copy only package-relevant files (template, files/, patches/)
                  cp -r "$srcdir/template" "srcpkgs/$pkgname/"
                  [ -d "$srcdir/files" ] && cp -r "$srcdir/files" "srcpkgs/$pkgname/"
                  [ -d "$srcdir/patches" ] && cp -r "$srcdir/patches" "srcpkgs/$pkgname/"
                  echo "   Updated $pkgname"
                  changed=true
              fi
          }

          sync_one_symlink() {
              pkgname="$1"
              link_target="$2"

              if [ -z "$link_target" ]; then
                  echo "   WARNING: empty symlink target for $pkgname, skipping"
                  return
              fi

              # If source symlink is absolute into the cloned temp repo, keep a
              # stable in-repo relative target instead.
              case "$link_target" in
                  */srcpkgs/*)
                      link_target="$(basename "$link_target")"
                      ;;
              esac

              printf '%s\n' "$pkgname" >> "$managed_file"

              if [ -L "srcpkgs/$pkgname" ] && [ "$(readlink "srcpkgs/$pkgname")" = "$link_target" ]; then
                  echo "   No changes for $pkgname (symlink -> $link_target)"
                  return
              fi

              rm -rf "srcpkgs/$pkgname"
              ln -s "$link_target" "srcpkgs/$pkgname"
              echo "   Updated $pkgname (symlink -> $link_target)"
              changed=true
          }

          sync_repo_all() {
              repo_url="$1"
              tmpdir="$2"

              if [ -d "$tmpdir/srcpkgs" ]; then
                  found=0
                  for pkgdir in "$tmpdir"/srcpkgs/*; do
                      [ -d "$pkgdir" ] || continue
                      found=1
                      pkgname="$(basename "$pkgdir")"
                      if [ -L "$pkgdir" ]; then
                          link_target="$(readlink "$pkgdir")"
                          echo "   -> syncing $pkgname (symlink)"
                          sync_one_symlink "$pkgname" "$link_target"
                      else
                          echo "   -> syncing $pkgname"
                          sync_one_pkg "$pkgname" "$pkgdir"
                      fi
                  done
                  if [ "$found" -eq 0 ]; then
                      echo "   WARNING: $repo_url has srcpkgs/ but no package dirs, skipping"
                  fi
                  return
              fi

              # Also allow a bare single-package template repo in "all" mode.
              if [ -f "$tmpdir/template" ]; then
                  pkgname="$(sed -n 's/^pkgname=//p' "$tmpdir/template" | head -n1 | sed -e 's/^"//' -e 's/"$//' -e "s/^'//" -e "s/'$//")"
                  if [ -z "$pkgname" ]; then
                      pkgname="$(basename "$repo_url" .git)"
                  fi
                  echo "   -> syncing $pkgname (root template)"
                  sync_one_pkg "$pkgname" "$tmpdir"
                  return
              fi

              echo "   WARNING: no srcpkgs/ or template found in $repo_url, skipping"
          }

          while IFS= read -r raw_line || [ -n "$raw_line" ]; do
              line="${raw_line%%#*}"
              line="$(printf '%s' "$line" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
              [ -z "$line" ] && continue

              set -- $line
              mode=""
              pkgname=""
              repo_url=""

              case "$1" in
                  all|@all|\*)
                      repo_url="$2"
                      mode="all"
                      ;;
                  *)
                      if [ "$#" -eq 1 ]; then
                          repo_url="$1"
                          case "$repo_url" in
                              *://*|git@*:* ) mode="all" ;;
                          esac
                      elif [ "$#" -ge 2 ]; then
                          pkgname="$1"
                          repo_url="$2"
                          mode="single"
                      fi
                      ;;
              esac

              if [ -z "$mode" ] || [ -z "$repo_url" ]; then
                  echo "WARNING: invalid packages.conf line: $raw_line"
                  continue
              fi

              if [ "$mode" = "single" ]; then
                  echo "==> Syncing $pkgname from $repo_url"
              else
                  echo "==> Syncing all packages from $repo_url"
              fi

              tmpdir=$(mktemp -d)
              if ! git clone --depth 1 "$repo_url" "$tmpdir"; then
                  echo "   WARNING: failed to clone $repo_url, skipping"
                  rm -rf "$tmpdir"
                  continue
              fi

              if [ "$mode" = "single" ]; then
                  # Source repos may expose package under srcpkgs/<pkg> or at repo root.
                  srcdir="$tmpdir"
                  if [ -d "$tmpdir/srcpkgs/$pkgname" ]; then
                      srcdir="$tmpdir/srcpkgs/$pkgname"
                  fi
                  if [ -L "$srcdir" ]; then
                      link_target="$(readlink "$srcdir")"
                      sync_one_symlink "$pkgname" "$link_target"
                  else
                      sync_one_pkg "$pkgname" "$srcdir"
                  fi
              else
                  # "all" mode: import every package in srcpkgs/* from this repo.
                  sync_repo_all "$repo_url" "$tmpdir"
              fi

              rm -rf "$tmpdir"
          done < packages.conf

          # Remove packages no longer declared in packages.conf.
          for d in srcpkgs/*; do
              [ -d "$d" ] || [ -L "$d" ] || continue
              pkg="$(basename "$d")"
              if ! grep -Fqx "$pkg" "$managed_file"; then
                  rm -rf "$d"
                  echo "   Removed stale package dir: $pkg"
                  changed=true
              fi
          done

          if [ "$changed" = true ]; then
              git config user.name "gitea-actions[bot]"
              git config user.email "gitea-actions[bot]@noreply.deadzone.lol"
              git add srcpkgs/
              if ! git diff --cached --quiet; then
                  git commit -m "sync: update package templates"
                  git push
              else
                  echo "Nothing to commit after staging"
              fi
          else
              echo "All packages up to date, nothing to push"
          fi
